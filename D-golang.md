# go

文档：https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/

## 基础

1.  = 和 :=的区别
    = 赋值， :=声明同时赋值
    **使用:=后循环体内的变量和循环体外的变量并不是同一个, 也就是作用域确实不同.** 
2. go中，很多函数会返回两个值，一个是函数本身的返回值，另一个代表函数执行是否成功的标识。可以多返回
3. error类型是一个简单的接口类型
4. Go语言局部变量分配在栈还是堆？
    Go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。
5. 

## goroutine

**调度原理**

1. M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）
2. P(processor): 表示逻辑processor，是线程M的执行的上下文。
3. G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。

## go-zero

**工具大于约定和文档的理念**，**编码自动化**

https://blog.csdn.net/yyz_1987/article/details/108367692

`go-zero` 集成了开箱即用的 **限流器** 。

1. periodlimit 
    `go-zero` 采取 **滑动窗口** 计数的方式，计算一段时间内对同一个资源的访问次数，如果超过指定的 `limit` ，则拒绝访问。当然如果你是在一段时间内访问不同的资源，每一个资源访问量都不超过 `limit` ，此种情况是允许大量请求进来的。
    1. 而在一个分布式系统中，存在多个微服务提供服务。所以当瞬间的流量同时访问同一个资源，如何让计数器在分布式系统中正常计数？ 同时在计算资源访问时，可能会涉及多个计算，如何保证计算的原子性？
    2. go-zero 借助 redis 的 incrby 做资源访问计数采用 lua script 做整个窗口计算，保证计算的原子性

后续处理

如果在服务某个时间点，请求大批量打进来，`periodlimit` 短期时间内达到 `limit` 阈值，而且设置的时间范围还远远没有到达。后续请求的处理就成为问题。

`periodlimit` 中并没有处理，而是返回 `code` 。把后续请求的处理交给了开发者自己处理。

1. 如果不做处理，那就是简单的将请求拒绝
2. 如果需要处理这些请求，开发者可以借助 `mq` 将请求缓冲，减缓请求的压力
3. 采用 `tokenlimit`，允许暂时的流量冲击